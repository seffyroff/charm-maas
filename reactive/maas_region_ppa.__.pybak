from charms.reactive import when, when_not, set_flag, clear_flag
from charmhelpers.core.hookenv import application_version_set, status_set, network_get, unitdata, config, open_port
from charmhelpers.fetch import get_upstream_version
import subprocess as sp
from charmhelpers.core.templating import render

PRIVATE_IP = network_get('http')['ingress-addresses'][0]
MAAS_WEB_PORT = 5240


set_flag('maas.mode.{}'.format(config('maas-mode')))

kv = unitdata.kv()

def maas_url():
    if config('maas-url'):
        return config('maas-url')
    else:
        return 'http://{}:5240/MAAS'.format(PRIVATE_IP)

# # Presistent unit data.
# unit_db = unitdata.kv()

# # Global config options
# global_configs = [
#     ('maas-name', 'maas_name', 'string'),
#     ('main-archive', 'main_archive', 'string'),
#     ('ports-archive', 'ports_archive', 'string'),
#     ('enable-http-proxy', 'enable_http_proxy', 'boolean'),
#     ('http-proxy', 'http_proxy', 'string'),
#     ('upstream-dns', 'upstream_dns', 'string'),
#     ('dnssec-validation', 'dnssec_validation', 'string'),
#     ('ntp-server', 'ntp_server', 'string'),
#     ('default-storage-layout', 'default_storage_layout', 'string'),
#     (
#      'enable-disk-erasing-on-release',
#      'enable_disk_erasing_on_release', 'boolean'),
#     ('curtin-verbose', 'curtin_verbose', 'boolean'),
]


@when_not('maas-region-ppa.installed')
def install_maas_region_ppa():
    set_flag('maas-region-ppa.installed')

@when('apt.installed.maas-region-controller')
def set_message_version():
    application_version_set(get_upstream_version('maas-region-controller'))

    message = sp.check_output('maas', '--version', stderr=sp.STDOUT)
    
    status_set('maintenance', message )

    set_flag('maas.version.set')
@when_not('postgresql.connected')
    status_set('Waiting for PGSQL Relation')

@when('postgresql.connected')
@when_not('maas.database.requested')
def request_postgresql_database_for_maas_region(pgsql):
    """Request PGSql DB
    """

    conf = config()
    status_set('maintenance', 'Requesting MAASDB')

    pgsql.set_database(conf.get('db-name', 'maasdb'))
    if conf.get('db-roles'):
        pgsql.set_roles(conf.get('db-roles'))
    if conf.get('db-extensions'):
        pgsql.set_extensions(conf.get('db-extensions'))
    status_set('active', 'MAASDB requested')
    set_flag('maas.database.requested')

@when('postgresql.master.available',
      'maas.database.requested')
@when_not('maas.juju.database.available')
def get_set_postgresql_data_for_maas_db(pgsql):
    """Get/set postgresql details
    """

    status_set('maintenance', 'Database acquired, saving details')
    kv.set('db_host', pgsql.master.host)
    kv.set('db_name', pgsql.master.dbname)
    kv.set('db_pass', pgsql.master.password)
    kv.set('db_user', pgsql.master.user)
    status_set('active', 'MAASDB saved to unitdata')

    clear_flag('maas.manual.database.available')
    set_flag('maas.juju.database.available')

@when('maas-region-ppa.installed')
@when_any('maas.juju.database.available',
          'maas.manual.database.available')
@when_not('maas.init.complete')
def maas_leader_init():
    """Init MAAS (region, region+rack) - only leader should run this code
    """
    status_set('maintenance',
               'Configuring MAAS-{}'.format(config('maas-mode')))

    init_ctxt = {'maas_url': maas_url(),
                 'maas_mode': config('maas-mode'),
                 'db_host': kv.get('db_host'),
                 'db_name': kv.get('db_name'),
                 'db_pass': kv.get('db_pass'),
                 'db_user': kv.get('db_user')}

    cmd_init = ('maas-region local_config_set --maas-url {maas_url} --database-host {db_host} '
                '--database-name {db_name} --database-user {db_user} '
                '--database-pass {db_pass}'
                '--force'.format(**init_ctxt))

    call(cmd_init.split())
    status_set('active', 'MAAS-{} configured'.format(config('maas-mode')))
    set_flag('maas.init.complete')


# def get_maas_secret():
#     """Return the MAAS secret value."""
#     with open('/var/lib/maas/secret', 'r') as fp:
#         return fp.read().strip()


# def get_apikey():
#     """Return the API key for the admin user."""
#     apikey = leadership.leader_get('apikey')
#     if not apikey:
#         apikey = check_output([
#             'maas-region', 'apikey',
#             '--username', leadership.leader_get('admin_username')])
#         apikey = apikey.decode('ascii').strip()
#         leadership.leader_set(apikey=apikey)
#     return apikey

# def update_config_value(charm_name, maas_name, value_type="string"):
#     """Update the global config values."""
#     if not hookenv.is_leader():
#         # Only the leader updates config values.
#         return
#     admin_username = leadership.leader_get('admin_username')
#     if not admin_username:
#         # Value can only be set once an administrator has been created.
#         return

#     # Ensure logged into API.
#     check_call([
#         'maas', 'login', 'juju-admin',
#         'http://localhost:5240/MAAS', get_apikey()])

#     # Get the current value.
#     result = check_output([
#         'maas', 'juju-admin', 'maas', 'get-config', 'name=%s' % maas_name])
#     result = result.decode("utf-8")
#     if value_type == "boolean":
#         if result == "true":
#             result = True
#         else:
#             result = False

#     # Update the value if its different.
#     new_value = hookenv.config(charm_name)
#     if result != new_value:
#         check_call([
#             'maas', 'juju-admin', 'maas',
#             'set-config', 'name=%s' % maas_name, 'value=%s' % new_value])


# def set_all_global_configs():
#     """Set all global configs.

#     Called after the administrator is first created.
#     """
#     hookenv.status_set('maintenance', 'Setting all global config options')
#     for charm_name, maas_name, value_type in global_configs:
#         update_config_value(charm_name, maas_name, value_type)


# def update_admin(old_username, username, email, password):
#     env = os.environ.copy()
#     env['DJANGO_SETTINGS_MODULE'] = 'maas.settings'
#     env['PYTHONPATH'] = '/usr/share/maas'
#     check_call([
#         'python3', 'scripts/update_user.py',
#         '--old-username', old_username,
#         '--username', username,
#         '--email', email,
#         '--password', password], env=env)

# @hook('config-changed')
# def update_global_configs():
#     config = hookenv.config()
#     for charm_name, maas_name, value_type in global_configs:
#         if config.changed(charm_name):
#             update_config_value(charm_name, maas_name, value_type)
# @hook('db-relation-joined')
# def db_joined(pgsql):
#     # psql layer does not handle departing correctly. We set
#     # db_joined so the write_db_config is not skipped.
#     unit_db.set('db_joined', True)
#     hookenv.status_set('waiting', 'Requesting database from PostgreSQL')
#     pgsql.set_database(hookenv.config('dbname'))


# @hook('db-relation-departed')
# def db_departed(pgsql):
#     # psql layer does not handle departing correctly. We clear
#     # db_joined so the write_db_config is skipped.
#     unit_db.unset('db_joined')
#     unit_db.unset('dbhost')
#     unit_db.unset('dbdb')
#     unit_db.unset('dbuser')
#     unit_db.unset('dbpass')
#     check_call([
#         'maas-region', 'local_config_set',
#         '--database-host', '',
#         '--database-name', '',
#         '--database-user', '',
#         '--database-pass', '',
#         ])
#     close_ports()
#     remove_state('regiond.running')
#     host.service_stop('maas-regiond')
#     hookenv.status_set('waiting', 'Waiting on relation to PostgreSQL')


# @when_any('config.changed.maas-url', 'config.changed.vip')
# def write_maas_url():
#     hookenv.status_set('maintenance', 'Writing maas_url into regiond.conf')
#     vip = hookenv.config('vip')
#     maas_url = hookenv.config('maas-url')
#     if vip:
#         if not is_valid_ip(vip):
#             url = ''
#         else:
#             url = 'http://%s/MAAS' % vip
#     elif maas_url:
#         url = maas_url
#     else:
#         url = 'http://localhost/MAAS'
#     check_call([
#         'maas-region', 'local_config_set',
#         '--maas-url', url,
#         ])
#     start_regiond_when_ready()


# @when_not('db.database.available')
# def missing_postgresql():
#     close_ports()
#     remove_state('regiond.running')
#     host.service_stop('maas-regiond')
#     hookenv.status_set('waiting', 'Waiting on relation to PostgreSQL')


# @when('db.database.available')
# def write_db_config(pgsql):
#     # Do nothing if not db joined.
#     if not unit_db.get('db_joined', False):
#         return

#     # Update the database configuration only if any of the configuration
#     # values have changed. Nothing needs to be done if nothing has changed.
#     dbhost = pgsql.host()
#     dbdb = pgsql.database()
#     dbuser = pgsql.user()
#     dbpass = pgsql.password()
#     has_changed = (
#         unit_db.get('dbhost') != dbhost or
#         unit_db.get('dbdb') != dbdb or
#         unit_db.get('dbuser') != dbuser or
#         unit_db.get('dbpass') != dbpass)
#     if has_changed:
#         unit_db.set('dbhost', dbhost)
#         unit_db.set('dbdb', dbdb)
#         unit_db.set('dbuser', dbuser)
#         unit_db.set('dbpass', dbpass)
#         hookenv.status_set(
#             'maintenance', 'Writing db configuration into regiond.conf')

#         check_call([
#             'maas-region', 'local_config_set',
#             '--database-host', dbhost if dbhost else '',
#             '--database-name', dbdb if dbdb else '',
#             '--database-user', dbuser if dbuser else '',
#             '--database-pass', dbpass if dbpass else '',
#             ])
#         if all([dbhost, dbdb, dbuser, dbpass]):
#             start_regiond_when_ready()
#         else:
#             remove_state('regiond.running')
#             host.service_stop('maas-regiond')
#             hookenv.status_set('waiting', 'Waiting on relation to PostgreSQL')


# @when_any(
#     'config.changed.haproxy-stats-enabled',
#     'config.changed.haproxy-stats-uri',
#     'config.changed.haproxy-stats-auth')
# def configure_haproxy():
#     """Write /etc/haproxy/haproxy.conf and reload haproxy."""
#     ha_units = unit_db.get('ha_units')
#     if ha_units is None:
#         ha_units = {}
#     templating.render('haproxy.cfg', '/etc/haproxy/haproxy.cfg', {
#         'stats_enabled': hookenv.config('haproxy-stats-enabled'),
#         'stats_uri': hookenv.config('haproxy-stats-uri'),
#         'stats_auth': hookenv.config('haproxy-stats-auth'),
#         'unit_name': hookenv.local_unit(),
#         'unit_address': hookenv.unit_private_ip(),
#         'ha_units': ha_units,
#     })


# @when('regiond.running')
# @when_any(
#     'config.changed.admin-username',
#     'config.changed.admin-email',
#     'config.changed.admin-password')
# def configure_admin_user():
#     """Configure administrator user."""
#     if hookenv.is_leader():
#         username = hookenv.config('admin-username')
#         email = hookenv.config('admin-email')
#         password = hookenv.config('admin-password')
#         if username and email and password:
#             admin_username = leadership.leader_get('admin_username')
#             if admin_username:
#                 # Change the admin username, email, and password.
#                 hookenv.status_set('maintenance', 'Leader: updating admin')
#                 update_admin(admin_username, username, email, password)
#                 leadership.leader_set(admin_username=username)
#             else:
#                 # Create the admin user.
#                 hookenv.status_set('maintenance', 'Leader: creating admin')
#                 check_call([
#                     'maas-region', 'createadmin',
#                     '--username', username,
#                     '--email', email,
#                     '--password', password,
#                 ])
#                 leadership.leader_set(admin_username=username)

#             # Update the state.
#             update_state()
